<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script async src="https://docs.opencv.org/master/opencv.js" onload="onOpenCvReady();"
        type="text/javascript"></script>
    <title>Dental Taper Angle and Symmetry Checker</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <style>
        body {
            background-color: #f8f9fa;
        }

        .container {
            margin-top: 30px;
        }

        .page-title {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #3498db;
        }

        #buttons-container {
            display: flex;
            justify-content: space-between;
        }

        #result-container {
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px auto;
            max-width: 600px;
        }

        #resultContainer p {
            margin: 0;
            font-size: 16px;
            line-height: 1.5;
        }

        .canvas-container {
            margin-top: 20px;
            position: relative;
        }

        canvas {
            border: 1px solid #3498db;
            cursor: pointer;
            background-color: #fff;
        }

        .green-text {
            color: green;
        }

        .orange-text {
            color: orange;
        }

        .red-text {
            color: red;
        }

        input[type="file"],
        button {
            margin-top: 20px;
            cursor: pointer;
        }

        label {
            display: inline-block;
            margin-top: 20px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 class="page-title">Dental Taper Angle and Symmetry Checker</h1>
        <div id="buttons-container" class="d-flex justify-content-between">
            <label for="imageInput" class="btn btn-primary">Upload Image</label>
            <input type="file" id="imageInput" accept="image/*" onchange="processImage()" style="display: none;">
            <button onclick="resetImage()" class="btn btn-danger">Reset</button>
        </div>
    </div>
    <div class="container">
        <div id="result-container">
            <div id="resultContainer"></div>
        </div>
    </div>
    <div class="container">
        <div class="canvas-container">
            <canvas id="originalCanvas" class="border"></canvas>
            <canvas id="canvas" onclick="handleCanvasClick(event)" class="border"></canvas>
        </div>
    </div>

    <script>
        let isOpencvReady = false;
        let originalImage;
        let points = [];
        let angles = [];
        let imgElement;
        let linesDrawn = false;

        function onOpenCvReady() {
            isOpencvReady = true;
        }

        function loadImageAndProcess(file) {
            originalImage = cv.imread(imgElement);
            const edges = new cv.Mat();
            const lines = new cv.Mat();

            // Convert the image to grayscale
            const gray = new cv.Mat();
            cv.cvtColor(originalImage, gray, cv.COLOR_RGBA2GRAY);

            // Apply Gaussian blur
            const blurred = new cv.Mat();
            //cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 1);
            cv.GaussianBlur(originalImage, blurred, new cv.Size(0, 0), 2);
            cv.addWeighted(originalImage, 1.5, blurred, -0.5, 0, originalImage);
            // Apply Canny edge detection
            cv.Canny(blurred, edges, 50, 150);

            // Dilate the image to connect components
            const dilated = new cv.Mat();
            const dilateSize = 1;
            const dilateKernel = cv.getStructuringElement(cv.MORPH_CROSS, new cv.Size(dilateSize, dilateSize));
            cv.dilate(edges, dilated, dilateKernel);

            // Use Hough transform to detect lines
            cv.HoughLines(dilated, lines, 1, Math.PI / 180, 100);

            // Display the original image
            const originalCanvas = document.getElementById('originalCanvas');
            const contextOriginal = originalCanvas.getContext('2d');
            originalCanvas.width = imgElement.width;
            originalCanvas.height = imgElement.height;
            contextOriginal.drawImage(imgElement, 0, 0, originalCanvas.width, originalCanvas.height);

            // Highlight the corners on the pre-processed image
            highlightCorners(originalImage, dilated);


            // Display the pre-processed image
            const canvas = document.getElementById('canvas');
            const context = canvas.getContext('2d');
            canvas.width = imgElement.width;
            canvas.height = imgElement.height;
            cv.imshow(canvas, dilated);

            // Highlight the corners on the pre-processed image
            highlightCorners2(canvas, dilated);

            // Add click event listener to the canvas
            canvas.addEventListener('click', function (event) {
                // Get the mouse coordinates relative to the canvas
                const x = event.offsetX;
                const y = event.offsetY;

                // Check if the clicked point is on a line
                checkIfPointOnLine(x, y, lines);
            });

            // Process the detected lines
            angles = [];
            for (let i = 0; i < lines.rows; ++i) {
                const rho = lines.data32F[i * 2];
                const theta = lines.data32F[i * 2 + 1];
                const angleDeg = (theta * 180) / Math.PI;

                // Store the angles for later evaluation
                angles.push(angleDeg);
            }

            // Print each angle in the angles array
            angles.forEach((angle) => {
                console.log(angle);
            });

            // Clean up
            gray.delete();
            blurred.delete();
            edges.delete();
            dilated.delete();
            dilateKernel.delete();
            lines.delete();
        }

        // Global array to store corner coordinates
        const cornerCoordinates = [];

        // Function to calculate Euclidean distance between two points
        function calculateDistance(point1, point2) {
            return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
        }

        // Draw lines connecting corners based on proximity
        function drawLinesBasedOnProximity(canvas, dilated, proximityThreshold) {
            const lineColor = [0, 0, 255, 255]; // Blue color for lines

            // Draw lines connecting corners based on proximity
            for (let i = 0; i < cornerCoordinates.length - 1; ++i) {
                const start = cornerCoordinates[i];
                const end = cornerCoordinates[i + 1];

                // Calculate the distance between consecutive corners
                const distance = calculateDistance(start, end);

                // Draw a line only if the distance is below the threshold
                if (distance < proximityThreshold) {
                    cv.line(dilated, new cv.Point(start.x, start.y), new cv.Point(end.x, end.y), lineColor, 2);
                }
            }

            cv.imshow(canvas, dilated);
        }

        // Function to highlight corners on the pre-processed image
        function highlightCorners2(canvas, dilated) {
            const corners = new cv.Mat();
            cv.goodFeaturesToTrack(dilated, corners, 0, 0.001, 10);

            const color = [255, 0, 0, 255]; // Red color for corners

            // Check if corners were detected
            if (corners.rows <= 0) {
                console.error('No corners detected.');
                return;
            }

            for (let i = 0; i < corners.rows; ++i) {
                const point = new cv.Point(corners.data32F[i * 2], corners.data32F[i * 2 + 1]);

                // Check if the point is in the upper half of the canvas
                if (point.y < dilated.rows / 2) {
                    // Increase the size of the points
                    cv.circle(dilated, point, 2, color, -1);

                    // Display coordinates next to the point
                    //const text = `(${point.x.toFixed(2)}, ${point.y.toFixed(2)})`;
                    //cv.putText(dilated, text, new cv.Point(point.x + 10, point.y - 10), cv.FONT_HERSHEY_SIMPLEX, 0.5, color, 1, cv.LINE_AA);

                    // Store coordinates in the array
                    cornerCoordinates.push({ x: point.x, y: point.y });
                }
            }

            // Draw lines based on proximity
            const proximityThreshold = 30; // Adjust the threshold as needed
            // drawLinesBasedOnProximity(canvas, dilated, proximityThreshold);

            cv.imshow(canvas, dilated);
            //printCornerCoordinates();
            corners.delete();
        }

        // Example usage
        //highlightCorners2(canvas, dilated);


        // Example usage of cornerCoordinates array
        function printCornerCoordinates() {
            cornerCoordinates.forEach((coord, index) => {
                console.log(`Corner ${index + 1}: (${coord.x}, ${coord.y})`);
            });
        }


        function drawPoint(context, point, radius, color) {
            context.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})`;
            context.beginPath();
            context.arc(point.x, point.y, radius, 0, 2 * Math.PI);
            context.fill();
        }


        // Function to check if a point is on a line
        function checkIfPointOnLine(x, y, lines) {
            for (let i = 0; i < lines.rows; ++i) {
                const rho = lines.data32F[i * 2];
                const theta = lines.data32F[i * 2 + 1];
                const a = Math.cos(theta);
                const b = Math.sin(theta);
                const x0 = a * rho;
                const y0 = b * rho;
                const x1 = x0 + 1000 * (-b);
                const y1 = y0 + 1000 * (a);
                const x2 = x0 - 1000 * (-b);
                const y2 = y0 - 1000 * (a);

                // Calculate the distance from the point to the line
                const distance = Math.abs((x2 - x1) * (y1 - y) - (x1 - x) * (y2 - y1)) /
                    Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

                // If the distance is within a threshold, consider it a click on the line
                if (distance < 2) {
                    console.log('Clicked on line:', i);
                    // Perform any additional actions you want when a line is clicked
                }
            }
        }

        function imgElementOnLoad() {
            const fileInput = document.getElementById('imageInput');
            const file = fileInput.files[0];
            if (!file) {
                alert("Please select an image.");
                return;
            }

            imgElement = new Image();
            imgElement.src = URL.createObjectURL(file);

            imgElement.onload = function () {
                if (imgElement.width > 500 || imgElement.height > 500) {
                    alert("Image dimensions should not exceed 500x500 pixels.");
                    return;
                }

                loadImageAndProcess(file);
            };
        }


        function processImage() {
            imgElementOnLoad();
        }

        function resetCanvasFromOriginal() {
            const originalCanvas = document.getElementById('originalCanvas');
            const contextOriginal = originalCanvas.getContext('2d');
            originalCanvas.width = imgElement.width;
            originalCanvas.height = imgElement.height;

            // Convert the original image to grayscale
            const grayImage = new cv.Mat();
            cv.cvtColor(originalImage, grayImage, cv.COLOR_RGBA2GRAY);

            // Display the grayscale image
            cv.imshow(originalCanvas, grayImage);

            // Clean up the grayscale image
            grayImage.delete();
        }

        function resetImage() {
            points = [];
            angles = [];
            const canvas = document.getElementById('canvas');
            const context = canvas.getContext('2d');
            context.clearRect(0, 0, canvas.width, canvas.height);
            resetCanvasFromOriginal();
            loadImageAndProcess();
            const resultElement = document.getElementById('resultContainer');
            resultElement.textContent = "";
        }

        function highlightCorners(src, dilated) {
            const corners = new cv.Mat();
            cv.goodFeaturesToTrack(dilated, corners, 100, 0.01, 10);

            for (let i = 0; i < corners.rows; ++i) {
                const point = new cv.Point(corners.data32F[i * 2], corners.data32F[i * 2 + 1]);
                cv.circle(src, point, 1, [0, 255, 0, 255], -1); // Highlight corners in green
            }

            cv.imshow('originalCanvas', src);

            corners.delete();
        }

        function handleCanvasClick(event) {
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Find the closest point considering both x and y axes
            let closestPoint = null;
            let minDistance = Number.MAX_VALUE;

            for (const point of cornerCoordinates) {
                const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));

                if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = point;
                }
            }
            points.push({ x: closestPoint.x, y: closestPoint.y });
            // Draw a point on the canvas
            const context = canvas.getContext('2d');
            if (points.length <= 4) {
                context.fillStyle = 'rgb(255, 0, 0)';;
                context.beginPath();
                context.arc(closestPoint.x, closestPoint.y, 5, 0, 2 * Math.PI);
                context.fill();
            }

            // Display coordinates on the canvas
            context.fillStyle = 'yellow';
            context.font = '12px Arial';
            //context.fillText(`(${closestPoint.x.toFixed(2)}, ${closestPoint.y.toFixed(2)})`, closestPoint.x + 10, closestPoint.y - 10);

            if (points.length === 4) {
                calculateAndDisplayTaperAngles();
                checkSymmetry();
            }
        }

        function calculateAndDisplayTaperAngles() {
            const resultContainer = document.getElementById('result-container');
            if (points.length < 4) {
                resultContainer.textContent = "Please click on four points to define the lines.";
                return;
            }

            // Calculate distances for taper angle
            const deltaY = points[1].y - points[0].y;
            const deltaX = points[1].x - points[0].x;
            const taperAngleRad = Math.atan2(deltaY, deltaX);
            const taperAngleDeg = Math.abs(90 + (taperAngleRad * 180) / Math.PI);

            const deltaY2 = points[3].y - points[2].y;
            const deltaX2 = points[3].x - points[2].x;
            const taperAngleRad2 = Math.atan2(deltaY2, deltaX2);
            const taperAngleDeg2 = Math.abs(90 + (taperAngleRad2 * 180) / Math.PI);

            // Calculer les coordonnées du point d'intersection
            const slope1 = (points[1].y - points[0].y) / (points[1].x - points[0].x);
            const yIntercept1 = points[0].y - slope1 * points[0].x;

            const slope2 = (points[3].y - points[2].y) / (points[3].x - points[2].x);
            const yIntercept2 = points[2].y - slope2 * points[2].x;

            const intersectionX = (yIntercept2 - yIntercept1) / (slope1 - slope2);
            const intersectionY = slope1 * intersectionX + yIntercept1;


            const line1 = {
                startX: points[0].x,
                startY: points[0].y,
                endX: intersectionX,
                endY: intersectionY
            };

            const line2 = {
                startX: points[2].x,
                startY: points[2].y,
                endX: intersectionX,
                endY: intersectionY
            };
            // Draw the lines on the canvas
            const canvas = document.getElementById('canvas');
            const context = canvas.getContext('2d');

            // Dessiner les lignes jusqu'au point d'intersection
            context.strokeStyle = 'green';
            context.lineWidth = 2;

            context.beginPath();
            context.moveTo(points[0].x, points[0].y);
            context.lineTo(intersectionX, intersectionY);
            context.stroke();

            context.beginPath();
            context.moveTo(points[2].x, points[2].y);
            context.lineTo(intersectionX, intersectionY);
            context.stroke();

            // Draw the angle text
            const centerX = (points[0].x + points[1].x) / 2;
            const centerY = (points[0].y + points[1].y) / 2;

            context.fillStyle = 'yellow';
            context.font = '14px Arial';
            context.fillText(` ${taperAngleDeg.toFixed(2)} °`, centerX - 40, centerY - 20);

            const centerX2 = (points[2].x + points[3].x) / 2;
            const centerY2 = (points[2].y + points[3].y) / 2;

            context.fillText(`${taperAngleDeg2.toFixed(2)} °`, centerX2 - 40, centerY2 - 20);

            // Calculer l'angle entre les deux lignes
            const angleBetweenLines = calculateAngleBetweenLines(line1, line2);

            // Afficher le texte de l'angle entre les deux lignes
            const centerX3 = (intersectionX + centerX2) / 2;
            const centerY3 = (intersectionY + centerY2) / 2;

            context.fillStyle = 'blue';
            context.fillText(`Convergence Angle: ${angleBetweenLines.toFixed(2)} °`, centerX3 - 40, centerY3 + 20);

            const sumOfFirstAndLastAngles = taperAngleDeg + taperAngleDeg2;

            // Display the results
            // Adjust color based on the criteria
            // Set default class to 'green-text'
            let className = 'green-text';

            // Adjust class based on the criteria
            if (sumOfFirstAndLastAngles > 16 && sumOfFirstAndLastAngles <= 21) {
                className = 'orange-text';
            } else if (sumOfFirstAndLastAngles > 21 || (sumOfFirstAndLastAngles >= 4 && sumOfFirstAndLastAngles < 6) || sumOfFirstAndLastAngles < 4) {
                className = 'red-text';
            }

            // Display the results with the dynamically determined class
            const resultHtml = `<p class="${className}">The first dental taper angle is: <strong>${taperAngleDeg.toFixed(2)} degrees</strong></p>
                <p class="${className}">The second dental taper angle is: <strong>${taperAngleDeg2.toFixed(2)} degrees</strong></p>
                <p class="${className}">Sum of angles: <strong>${sumOfFirstAndLastAngles.toFixed(2)} degrees</strong></p>
                <p class="${className}">Angle between lines: <strong>${angleBetweenLines.toFixed(2)} degrees</strong></p>
                <p>${checkSymmetry()}</p>`;
            resultContainer.innerHTML = resultHtml;
            evaluateSumOfAngles(sumOfFirstAndLastAngles);
        }

        // Modifier la fonction calculateAngleBetweenLines pour prendre en compte les points de départ et d'arrêt des lignes
        function calculateAngleBetweenLines(line1, line2) {
            const vector1 = {
                x: line1.endX - line1.startX,
                y: line1.endY - line1.startY
            };

            const vector2 = {
                x: line2.endX - line2.startX,
                y: line2.endY - line2.startY
            };

            const dotProd = dotProduct(vector1, vector2);
            const mag1 = magnitude(vector1);
            const mag2 = magnitude(vector2);

            // Assurez-vous que le produit scalaire est dans la plage valide pour acos
            const dotClamped = Math.max(-1, Math.min(dotProd / (mag1 * mag2), 1));

            const angleRad = Math.acos(dotClamped);

            // Déterminez le signe de l'angle en fonction du produit vectoriel des vecteurs
            const crossProduct = vector1.x * vector2.y - vector1.y * vector2.x;
            const angleDeg = (crossProduct >= 0) ? (angleRad * 180) / Math.PI : -(angleRad * 180) / Math.PI;

            return Math.abs(angleDeg);
        }

        // Calcul du produit scalaire entre deux vecteurs
        function dotProduct(vector1, vector2) {
            return vector1.x * vector2.x + vector1.y * vector2.y;
        }

        // Calcul de la magnitude (norme) d'un vecteur
        function magnitude(vector) {
            return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
        }




        function drawTangentLine(point, angleRad, color, isOutside) {
            const canvas = document.getElementById('canvas');
            const context = canvas.getContext('2d');

            const length = 50;
            const direction = isOutside ? 1 : -1;

            // Calculer les coordonnées de l'autre extrémité de la ligne
            const endX = point.x + direction * length * Math.cos(angleRad);
            const endY = point.y + direction * length * Math.sin(angleRad);

            // Dessiner la ligne
            context.strokeStyle = color;
            context.lineWidth = 5;
            context.beginPath();
            context.moveTo(point.x, point.y);
            context.lineTo(endX, endY);
            context.stroke();
        }


        function evaluateSumOfAngles(sumOfAngles) {
            const resultElement = document.getElementById('resultContainer');
            if (sumOfAngles >= 6 && sumOfAngles <= 16) {
                resultElement.textContent += '\nPerfect taper.';
            } else if (sumOfAngles > 0 && sumOfAngles < 6) {
                resultElement.textContent += '\nAgainst taper.';
            } else if (sumOfAngles > 16) {
                resultElement.textContent += '\nExcessive taper.';
            }
        }




        function evaluateSumOfAngles(sumOfAngles) {
            const resultElement = document.getElementById('resultContainer');
            if (sumOfAngles >= 6 && sumOfAngles <= 16) {
                resultElement.textContent += '\nPerfect taper.';
            } else if (sumOfAngles > 0 && sumOfAngles < 6) {
                resultElement.textContent += '\nAgainst taper.';
            } else if (sumOfAngles > 16) {
                resultElement.textContent += '\nExcessive taper.';
            }
        }

        function checkSymmetry() {
            const resultElement = document.getElementById('result-container');
            const deltaX1 = Math.abs(points[0].x - points[1].x);
            const deltaX2 = Math.abs(points[2].x - points[3].x);
            const deltaY1 = Math.abs(points[0].y - points[1].y);
            const deltaY2 = Math.abs(points[2].y - points[3].y);

            const isSymmetrical = Math.abs(deltaX1 - deltaX2) < 5 && Math.abs(deltaY1 - deltaY2) < 5;

            return '\nSymmetry: ' + (isSymmetrical ? "Symmetrical" : "Not Symmetrical");
        }
    </script>
    <!-- Bootstrap JS, Popper.js, and jQuery -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"
        integrity="sha384-gzFDBJ0d6bl/2bMqz4EMfRr4Bd1zwoQe8b1BM6UE5zHjU9cRaxUIjtJ2Ib59iSpD"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
        crossorigin="anonymous"></script>

</body>

</html>